/* GENERATION_METADATA: {"templateHash":"914a89f75af74206680a89bfcecf37c098fd3941c47ccdee17ce99a483b82e5a","configHash":"06a6f650ad570ca1cbaa810a6aed40ddc930f9e34cfb878309976d3e4a7e2c00","generatedAt":"2025-07-09T02:29:15.089Z","version":"1.0.0"} */
/* eslint-disable */
/**
 * API Mesh Resolvers - True Mesh Pattern with Performance Analysis
 * Auto-generated by scripts/generate-mesh-resolver.js
 *
 * This implementation uses the configured Commerce REST API source
 * with admin token authentication via operationHeaders.
 */

// Configuration from injected config (replaced during generation)
const meshConfig = {
  commerceBaseUrl: 'https://citisignal-com774.adobedemo.com',
  pagination: {
    defaultPageSize: 150,
    maxPages: 25,
  },
  batching: {
    categories: 20,
    inventory: 25,
    maxConcurrent: 15,
    requestDelay: 75,
  },
  timeout: 30000,
  retries: 3,
};

const commerceBaseUrl = 'https://citisignal-com774.adobedemo.com';

// Add category caching for efficiency (like REST API has)
const categoryCache = new Map();
const CACHE_TTL = 300000; // Cache TTL from configuration

/**
 * Get cached category data
 * @param {string} categoryId - Category ID
 * @returns {Object|null} Cached category data or null
 */
function getCachedCategory(categoryId) {
  const cached = categoryCache.get(categoryId);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.data;
  }
  if (cached) {
    categoryCache.delete(categoryId);
  }
  return null;
}

/**
 * Cache category data
 * @param {string} categoryId - Category ID
 * @param {Object} data - Category data
 */
function cacheCategory(categoryId, data) {
  categoryCache.set(categoryId, {
    timestamp: Date.now(),
    data: data,
  });
}

/**
 * Build category map from cache
 * @param {string[]} categoryIds - Array of category IDs
 * @returns {Object} Category map from cache
 */
function buildCategoryMapFromCache(categoryIds) {
  const categoryMap = {};
  categoryIds.forEach((id) => {
    const cached = getCachedCategory(id);
    if (cached) {
      categoryMap[id] = cached;
    }
  });
  return categoryMap;
}

// Web Crypto API-based OAuth implementation for API Mesh
async function createOAuthHeader(oauthParams, method, url) {
  const { consumerKey, consumerSecret, accessToken, accessTokenSecret } = oauthParams;

  // OAuth 1.0 parameters
  const timestamp = Math.floor(Date.now() / 1000).toString();
  const nonce = Array.from(crypto.getRandomValues(new Uint8Array(16)), (b) =>
    b.toString(16).padStart(2, '0')
  ).join('');

  // Parse URL to get base URL and parameters
  const urlObj = new URL(url);
  const baseUrl = urlObj.protocol + '//' + urlObj.host + urlObj.pathname;

  // Collect OAuth parameters
  const oauthSignatureParams = {
    oauth_consumer_key: consumerKey,
    oauth_token: accessToken,
    oauth_signature_method: 'HMAC-SHA256',
    oauth_timestamp: timestamp,
    oauth_nonce: nonce,
    oauth_version: '1.0',
  };

  // Collect query parameters
  const queryParams = {};
  for (const [key, value] of urlObj.searchParams) {
    queryParams[key] = value;
  }

  // Combine all parameters for signature base
  const allParams = { ...oauthSignatureParams, ...queryParams };

  // Create parameter string (percent encode keys and values, then sort)
  const parameterString = Object.keys(allParams)
    .sort()
    .map((key) => percentEncode(key) + '=' + percentEncode(allParams[key]))
    .join('&');

  // Create signature base string
  const signatureBaseString =
    method.toUpperCase() + '&' + percentEncode(baseUrl) + '&' + percentEncode(parameterString);

  // Create signing key
  const signingKey = percentEncode(consumerSecret) + '&' + percentEncode(accessTokenSecret);

  // Generate HMAC-SHA256 signature using Web Crypto API
  const signature = await generateHmacSignature(signingKey, signatureBaseString);

  // Add signature to OAuth parameters
  oauthSignatureParams.oauth_signature = signature;

  // Create Authorization header
  const headerParams = Object.keys(oauthSignatureParams)
    .sort()
    .map((key) => percentEncode(key) + '="' + percentEncode(oauthSignatureParams[key]) + '"')
    .join(', ');

  return 'OAuth ' + headerParams;
}

// Web Crypto API HMAC-SHA256 implementation
async function generateHmacSignature(key, data) {
  try {
    // Convert strings to ArrayBuffer
    const keyBuffer = new TextEncoder().encode(key);
    const dataBuffer = new TextEncoder().encode(data);

    // Import the key for HMAC
    const cryptoKey = await crypto.subtle.importKey(
      'raw',
      keyBuffer,
      {
        name: 'HMAC',
        hash: 'SHA-256',
      },
      false,
      ['sign']
    );

    // Generate signature
    const signatureBuffer = await crypto.subtle.sign('HMAC', cryptoKey, dataBuffer);

    // Convert to base64
    const signatureArray = new Uint8Array(signatureBuffer);
    let binaryString = '';
    for (let i = 0; i < signatureArray.length; i++) {
      binaryString += String.fromCharCode(signatureArray[i]);
    }

    return btoa(binaryString);
  } catch (error) {
    throw new Error('Failed to generate HMAC signature: ' + error.message);
  }
}

// Percent encoding for OAuth (RFC 3986)
function percentEncode(str) {
  if (str === null || str === undefined) return '';
  return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

// Main mesh products resolver with Web Crypto OAuth
async function fetchAllProductsFromSource(context, pageSize, maxPages, performance = null) {
  const stepStart = Date.now();
  const allProducts = [];
  let currentPage = 1;

  // Get OAuth credentials from context headers
  const oauthParams = {
    consumerKey: context.headers['x-commerce-consumer-key'],
    consumerSecret: context.headers['x-commerce-consumer-secret'],
    accessToken: context.headers['x-commerce-access-token'],
    accessTokenSecret: context.headers['x-commerce-access-token-secret'],
  };

  if (
    !oauthParams.consumerKey ||
    !oauthParams.consumerSecret ||
    !oauthParams.accessToken ||
    !oauthParams.accessTokenSecret
  ) {
    throw new Error(
      'OAuth credentials required in headers: x-commerce-consumer-key, x-commerce-consumer-secret, x-commerce-access-token, x-commerce-access-token-secret'
    );
  }

  try {
    while (currentPage <= maxPages) {
      const url =
        commerceBaseUrl +
        '/rest/V1/products?searchCriteria[pageSize]=' +
        pageSize +
        '&searchCriteria[currentPage]=' +
        currentPage +
        '&fields=items[id,sku,name,price,status,type_id,attribute_set_id,created_at,updated_at,weight,categories,media_gallery_entries[file,url,position,types],custom_attributes],total_count';

      const authHeader = await createOAuthHeader(oauthParams, 'GET', url);

      // Track API call
      if (performance) {
        performance.productsApiCalls++;
        performance.totalApiCalls++;
      }

      const response = await fetch(url, {
        method: 'GET',
        headers: {
          Authorization: authHeader,
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        throw new Error(
          'Products API request failed: ' + response.status + ' ' + response.statusText
        );
      }

      const data = await response.json();

      if (!data.items || !Array.isArray(data.items)) {
        break;
      }

      allProducts.push(...data.items);

      if (
        data.items.length < pageSize ||
        !data.total_count ||
        allProducts.length >= data.total_count
      ) {
        break;
      }

      currentPage++;
    }

    return allProducts;
  } catch (error) {
    throw new Error('Failed to fetch products: ' + error.message);
  }
}

async function fetchCategoriesFromSource(context, categoryIds, performance = null) {
  const stepStart = Date.now();
  const categoryMap = {};
  const batchSize = meshConfig.batching.categories;

  if (categoryIds.length === 0) {
    return categoryMap;
  }

  // OPTIMIZATION: Check cache first and only fetch uncached categories
  const cachedCategories = buildCategoryMapFromCache(categoryIds);
  Object.assign(categoryMap, cachedCategories);

  // Filter out already cached categories
  const uncachedIds = categoryIds.filter((id) => !getCachedCategory(id));

  // Track cache performance
  const cachedCount = categoryIds.length - uncachedIds.length;
  if (performance) {
    performance.categoriesCached = cachedCount;
    performance.categoriesFetched = uncachedIds.length;
  }

  if (uncachedIds.length === 0) {
    // All categories were cached - 0 API calls needed!
    console.log('All', categoryIds.length, 'categories served from cache - 0 API calls');
    return categoryMap;
  }

  console.log('Cache hit for', cachedCount, 'categories, fetching', uncachedIds.length, 'from API');

  // Get OAuth credentials from context headers
  const oauthParams = {
    consumerKey: context.headers['x-commerce-consumer-key'],
    consumerSecret: context.headers['x-commerce-consumer-secret'],
    accessToken: context.headers['x-commerce-access-token'],
    accessTokenSecret: context.headers['x-commerce-access-token-secret'],
  };

  if (
    !oauthParams.consumerKey ||
    !oauthParams.consumerSecret ||
    !oauthParams.accessToken ||
    !oauthParams.accessTokenSecret
  ) {
    throw new Error('OAuth credentials required for categories');
  }

  try {
    // Process uncached categories in batches
    for (let i = 0; i < uncachedIds.length; i += batchSize) {
      const batch = uncachedIds.slice(i, i + batchSize);

      const promises = batch.map(async (categoryId) => {
        const url = commerceBaseUrl + '/rest/V1/categories/' + categoryId;
        const authHeader = await createOAuthHeader(oauthParams, 'GET', url);

        // Track API call
        if (performance) {
          performance.categoriesApiCalls++;
          performance.totalApiCalls++;
        }

        const response = await fetch(url, {
          method: 'GET',
          headers: {
            Authorization: authHeader,
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          console.warn('Category ' + categoryId + ' fetch failed: ' + response.status);
          return null;
        }

        const category = await response.json();

        // Cache the fetched category
        cacheCategory(categoryId, category);

        return { id: categoryId, data: category };
      });

      const results = await Promise.all(promises);

      results.forEach((result) => {
        if (result && result.data) {
          categoryMap[result.id] = result.data;
        }
      });
    }

    return categoryMap;
  } catch (error) {
    throw new Error('Failed to fetch categories: ' + error.message);
  }
}

/**
 * Get admin Bearer token using username/password authentication
 * @param {Object} context - GraphQL context with headers
 * @param {Object} [performance] - Optional performance tracking
 * @returns {Promise<string>} Bearer token
 */
async function getAdminToken(context, performance = null) {
  const username = context.adminCredentials?.username;
  const password = context.adminCredentials?.password;

  if (!username || !password) {
    throw new Error(
      'Admin credentials required for inventory: adminUsername and adminPassword GraphQL variables'
    );
  }

  const tokenUrl =
    'https://citisignal-com774.adobedemo.com' + '/rest/all/V1/integration/admin/token';

  // Track API call
  if (performance) {
    performance.inventoryApiCalls++;
    performance.totalApiCalls++;
  }

  const response = await fetch(tokenUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ username, password }),
  });

  if (!response.ok) {
    throw new Error('Failed to get admin token: ' + response.status + ' ' + response.statusText);
  }

  const token = await response.json();
  return token; // Returns the bearer token string
}

async function fetchInventoryFromSource(context, skus, performance = null) {
  const stepStart = Date.now();
  const inventoryMap = {};

  try {
    // Use Bearer token authentication for inventory (like REST API does)
    const bearerToken = await getAdminToken(context, performance);
    const batchSize = meshConfig.batching.inventory;

    console.log('Fetching inventory for', skus.length, 'SKUs with Bearer token');

    for (let i = 0; i < skus.length; i += batchSize) {
      const batch = skus.slice(i, i + batchSize);

      // Use same format as working REST API
      const searchCriteria = {
        filterGroups: [
          {
            filters: [
              {
                field: 'sku',
                value: batch.join(','),
                conditionType: 'in',
              },
            ],
          },
        ],
      };

      const queryParams = new URLSearchParams({
        searchCriteria: JSON.stringify(searchCriteria),
      });

      const url =
        'https://citisignal-com774.adobedemo.com' +
        '/rest/all/V1/inventory/source-items?' +
        queryParams.toString();

      console.log('Calling inventory API:', url.substring(0, 100) + '...');

      // Track API call
      if (performance) {
        performance.inventoryApiCalls++;
        performance.totalApiCalls++;
      }

      const response = await fetch(url, {
        method: 'GET',
        headers: {
          Authorization: 'Bearer ' + bearerToken,
          'Content-Type': 'application/json',
        },
      });

      console.log('Inventory API response status:', response.status);

      if (!response.ok) {
        const errorText = await response.text();
        console.warn(
          'Inventory batch fetch failed: ' +
            response.status +
            ' ' +
            response.statusText +
            ' - ' +
            errorText
        );
        continue;
      }

      const data = await response.json();
      console.log('Inventory API returned', data.items?.length || 0, 'items');

      if (data.items && Array.isArray(data.items)) {
        data.items.forEach((item) => {
          if (item.sku) {
            console.log('Inventory for', item.sku, ':', item.quantity);
            inventoryMap[item.sku] = {
              qty: item.quantity || 0,
              is_in_stock: item.status === 1,
            };
          }
        });
      }
    }

    console.log('Final inventory map has', Object.keys(inventoryMap).length, 'entries');
    return inventoryMap;
  } catch (error) {
    console.error('Inventory fetch error:', error);
    throw new Error('Failed to fetch inventory: ' + error.message);
  }
}

// Export the resolvers
module.exports = {
  resolvers: {
    Query: {
      mesh_products_enriched: {
        resolve: async (parent, args, context) => {
          try {
            const startTime = Date.now();
            const pageSize = args.pageSize || meshConfig.pagination.defaultPageSize;
            const maxPages = meshConfig.pagination.maxPages;

            // Initialize performance tracking with comprehensive metrics
            const performance = {
              // Traditional metrics (for comparison)
              processedProducts: 0,
              apiCalls: 0,
              productsApiCalls: 0,
              categoriesApiCalls: 0,
              inventoryApiCalls: 0,
              totalApiCalls: 0,
              uniqueCategories: 0,
              productCount: 0,
              skuCount: 0,
              method: 'API Mesh',
              executionTime: 0,

              // Client-perspective efficiency metrics (calculated dynamically)
              clientCalls: 1, // Client makes only 1 GraphQL query (always true)
              dataSourcesUnified: 0, // Will be calculated based on actual APIs called
              queryConsolidation: null, // Will be calculated as "X:1" ratio
              cacheHitRate: 0, // Percentage of cached categories
              categoriesCached: 0, // Number of categories served from cache
              categoriesFetched: 0, // Number of categories fetched from API

              // Mesh advantages (calculated dynamically)
              operationComplexity: 'single-query', // Always true for GraphQL mesh
              dataFreshness: 'real-time', // Mesh gets fresh data
              clientComplexity: 'minimal', // Client sends 1 query vs orchestrating multiple
              apiOrchestration: 'automated', // Mesh handles all coordination
              parallelization: 'automatic', // Mesh handles parallel data fetching
              meshOptimizations: [], // Will be populated with actual optimizations used
            };

            // Store admin credentials from GraphQL arguments
            context.adminCredentials = {
              username: args.adminUsername,
              password: args.adminPassword,
            };

            // Step 1: Fetch all products
            const allProducts = await fetchAllProductsFromSource(
              context,
              pageSize,
              maxPages,
              performance
            );

            // Step 2: Extract category IDs and SKUs
            const categoryIds = new Set();
            const skus = [];

            allProducts.forEach((product) => {
              // Extract SKUs
              if (product.sku) {
                skus.push(product.sku);
              }

              // Extract category IDs from custom attributes
              if (product.custom_attributes && Array.isArray(product.custom_attributes)) {
                product.custom_attributes.forEach((attr) => {
                  if (attr.attribute_code === 'category_ids' && attr.value) {
                    try {
                      const ids = Array.isArray(attr.value) ? attr.value : attr.value.split(',');
                      ids.forEach((id) => categoryIds.add(id.toString()));
                    } catch (e) {
                      // Skip invalid category IDs
                    }
                  }
                });
              }
            });

            // Step 3: Fetch category and inventory data in parallel
            const [categoryMap, inventoryMap] = await Promise.all([
              fetchCategoriesFromSource(context, Array.from(categoryIds), performance),
              fetchInventoryFromSource(context, skus, performance),
            ]);

            // Step 4: Enrich products with category and inventory data (RAW - no transformation)
            const enrichedProducts = allProducts.map((product) => {
              const sku = product.sku;
              const inventory = inventoryMap[sku] || { qty: 0, is_in_stock: false };

              // Extract category objects from custom attributes
              let categoryObjects = [];
              if (product.custom_attributes && Array.isArray(product.custom_attributes)) {
                product.custom_attributes.forEach((attr) => {
                  if (attr.attribute_code === 'category_ids' && attr.value) {
                    try {
                      const ids = Array.isArray(attr.value) ? attr.value : attr.value.split(',');
                      categoryObjects = ids
                        .map((id) => categoryMap[id.toString()])
                        .filter((cat) => cat)
                        .map((cat) => ({ id: cat.id, name: cat.name }));
                    } catch (e) {
                      // Skip invalid category data
                    }
                  }
                });
              }

              // Return RAW consolidated data - let buildProducts step handle transformation
              // Sort media_gallery_entries to prioritize AEM URLs (starting with http) over catalog paths
              let sortedMediaGallery = [];
              if (product.media_gallery_entries && Array.isArray(product.media_gallery_entries)) {
                sortedMediaGallery = [...product.media_gallery_entries].sort((a, b) => {
                  const aIsUrl = a.file && a.file.startsWith('http');
                  const bIsUrl = b.file && b.file.startsWith('http');

                  // AEM URLs (starting with http) should come first
                  if (aIsUrl && !bIsUrl) return -1;
                  if (!aIsUrl && bIsUrl) return 1;

                  // If both are URLs or both are paths, maintain original order
                  return 0;
                });
              }

              return {
                ...product,
                qty: inventory.qty,
                categories: categoryObjects, // Raw category objects with id/name
                inventory: inventory,
                media_gallery_entries: sortedMediaGallery, // AEM URLs prioritized over catalog paths
              };
            });

            // Calculate final performance metrics
            const endTime = Date.now();
            performance.executionTime = (endTime - startTime) / 1000; // Convert to seconds
            performance.processedProducts = enrichedProducts.length;
            performance.productCount = enrichedProducts.length;
            performance.skuCount = skus.length;
            performance.uniqueCategories = categoryIds.size;

            // Calculate dynamic client-perspective efficiency metrics

            // Count actual data sources used
            let sourcesUsed = 0;
            if (performance.productsApiCalls > 0) sourcesUsed++; // Products API
            if (performance.categoriesApiCalls > 0 || performance.categoriesCached > 0)
              sourcesUsed++; // Categories API/Cache
            if (performance.inventoryApiCalls > 0) sourcesUsed++; // Inventory API
            performance.dataSourcesUnified = sourcesUsed;

            // Calculate actual mesh consolidation ratio
            // Use actual calls made by mesh for consistency
            const actualMeshCalls = performance.totalApiCalls || performance.apiCalls;
            performance.queryConsolidation = actualMeshCalls + ':1';

            // Calculate actual cache hit rate
            if (performance.categoriesCached + performance.categoriesFetched > 0) {
              performance.cacheHitRate = Math.round(
                (performance.categoriesCached /
                  (performance.categoriesCached + performance.categoriesFetched)) *
                  100
              );
            }

            // Populate mesh optimizations based on actual execution
            performance.meshOptimizations = [];
            if (performance.categoriesCached > 0) {
              performance.meshOptimizations.push('Category Caching');
            }
            if (performance.dataSourcesUnified > 1) {
              performance.meshOptimizations.push('Multi-API Consolidation');
            }
            if (performance.categoriesApiCalls > 0 && performance.inventoryApiCalls > 0) {
              performance.meshOptimizations.push('Parallel Data Fetching');
            }
            if (performance.queryConsolidation && performance.queryConsolidation !== '1:1') {
              performance.meshOptimizations.push('Query Consolidation');
            }

            return {
              products: enrichedProducts,
              total_count: enrichedProducts.length,
              message:
                'Successfully fetched ' +
                enrichedProducts.length +
                ' products with category and inventory data',
              status: 'success',
              performance: performance,
            };
          } catch (error) {
            console.error('Mesh resolver error:', error);
            throw new Error('Failed to fetch enriched products: ' + error.message);
          }
        },
      },
    },
  },
};
