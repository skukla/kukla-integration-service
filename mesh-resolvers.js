/* GENERATION_METADATA: {"templateHash":"9ff66b1bf2ad17e165cf7f044896c9bd9cf9d9204ba8d87e03c3ab92deef5e98","configHash":"1ee5ec6b14a02b2056d1d1cd9c3277c7f02115a98acd724d0f4e3b63905e3e40","generatedAt":"2025-06-30T04:29:31.560Z","version":"1.0.0"} */
/* GENERATION_METADATA: {"templateHash":"dd2969d8d7b29e0bb047422f60c177457ad1dc48d3cc6ebc221abbd09ae7b3ee","configHash":"f9b465e5b2e75c29ed4e701d3bd084d7827f8aa545ab3123626de7668748d184","generatedAt":"2025-06-30T00:53:26.971Z","version":"1.0.0"} */
/* eslint-disable */
/**
 * API Mesh Resolvers - True Mesh Pattern with Performance Analysis
 * Auto-generated by scripts/generate-mesh-resolver.js
 *
 * This implementation uses the configured Commerce REST API source
 * with admin token authentication via operationHeaders.
 */

module.exports = {
  resolvers: {
    Query: {
      mesh_products_enriched: {
        resolve: async (parent, args, context) => {
          const startTime = Date.now();
          const performanceMetrics = {
            steps: {},
            apiCalls: {
              products: 0,
              categories: 0,
              inventory: 0,
              total: 0,
            },
            timing: {},
          };

          try {
            // Get admin token from headers (will be passed to operationHeaders)
            const adminToken = context.headers['x-commerce-admin-token'];

            if (!adminToken) {
              throw new Error('Admin token required via x-commerce-admin-token header');
            }

            // Configuration from injected config
            const meshConfig = {
              pagination: {
                defaultPageSize: 150,
                maxPages: 25,
              },
              batching: {
                categories: 20,
                inventory: 20,
                maxConcurrent: 10,
                requestDelay: 100,
              },
              timeout: 30000,
              retries: 3,
            };
            const pageSize = args.pageSize || meshConfig.pagination.defaultPageSize;
            const maxPages = args.maxPages || meshConfig.pagination.maxPages;

            // STEP 1: Fetch all products
            const step1Start = Date.now();
            const allProducts = await fetchAllProductsFromSource(
              context,
              pageSize,
              maxPages,
              performanceMetrics
            );
            const step1Time = Date.now() - step1Start;
            performanceMetrics.steps.productFetch = step1Time;
            performanceMetrics.timing.productFetch = step1Time + 'ms';

            // STEP 2: Extract category IDs and SKUs
            const step2Start = Date.now();
            const categoryIds = new Set();
            const skus = [];

            allProducts.forEach((product) => {
              skus.push(product.sku);

              // Extract category IDs from various locations
              if (Array.isArray(product.category_ids)) {
                product.category_ids.forEach((id) => categoryIds.add(String(id)));
              }

              if (Array.isArray(product.custom_attributes)) {
                product.custom_attributes.forEach((attr) => {
                  if (attr.attribute_code === 'category_ids' && Array.isArray(attr.value)) {
                    attr.value.forEach((id) => categoryIds.add(String(id)));
                  }
                });
              }
            });

            const step2Time = Date.now() - step2Start;
            performanceMetrics.steps.dataExtraction = step2Time;
            performanceMetrics.timing.dataExtraction = step2Time + 'ms';

            // STEP 3: Fetch category and inventory data in parallel
            const step3Start = Date.now();
            const [categoryMap, inventoryMap] = await Promise.all([
              fetchCategoriesFromSource(context, Array.from(categoryIds), performanceMetrics),
              fetchInventoryFromSource(context, skus, performanceMetrics),
            ]);
            const step3Time = Date.now() - step3Start;
            performanceMetrics.steps.parallelFetch = step3Time;
            performanceMetrics.timing.parallelFetch = step3Time + 'ms';

            // STEP 4: Enrich products with category, inventory, and image data
            const step4Start = Date.now();

            // MEMORY OPTIMIZATION: Pre-allocate array with known size
            const enrichedProducts = new Array(allProducts.length);

            // SIMPLIFIED OPTIMIZATION: Use map with pre-allocated array
            allProducts.forEach((product, index) => {
              // Get inventory data
              const inventory = inventoryMap[product.sku] || { qty: 0, is_in_stock: false };

              // Add inventory to product as qty field for compatibility
              const enrichedProduct = {
                ...product,
                qty: inventory.qty,
                inventory: {
                  qty: inventory.qty,
                  is_in_stock: inventory.is_in_stock,
                },
              };

              // Add category objects for buildProducts compatibility
              const categoryObjects = [];

              // From direct category_ids
              if (Array.isArray(product.category_ids)) {
                product.category_ids.forEach((id) => {
                  const categoryName = categoryMap[String(id)];
                  if (categoryName) {
                    categoryObjects.push({ id: String(id), name: categoryName });
                  }
                });
              }

              // From custom_attributes
              if (Array.isArray(product.custom_attributes)) {
                product.custom_attributes.forEach((attr) => {
                  if (attr.attribute_code === 'category_ids' && Array.isArray(attr.value)) {
                    attr.value.forEach((id) => {
                      const categoryName = categoryMap[String(id)];
                      if (categoryName) {
                        categoryObjects.push({ id: String(id), name: categoryName });
                      }
                    });
                  }
                });
              }

              // Add categories in the format expected by buildProducts
              if (categoryObjects.length > 0) {
                enrichedProduct.categories = categoryObjects;
              }

              // Add images in the format expected by buildProducts
              if (
                Array.isArray(product.media_gallery_entries) &&
                product.media_gallery_entries.length > 0
              ) {
                enrichedProduct.images = product.media_gallery_entries.map(transformImageEntry);
              }

              enrichedProducts[index] = enrichedProduct;
            });

            const step4Time = Date.now() - step4Start;
            performanceMetrics.steps.dataEnrichment = step4Time;
            performanceMetrics.timing.dataEnrichment = step4Time + 'ms';

            const executionTime = Date.now() - startTime;

            // Calculate API call totals
            performanceMetrics.apiCalls.total =
              performanceMetrics.apiCalls.products +
              performanceMetrics.apiCalls.categories +
              performanceMetrics.apiCalls.inventory;

            return {
              products: enrichedProducts,
              total_count: enrichedProducts.length,
              message:
                'Successfully fetched and enriched ' +
                enrichedProducts.length +
                ' products with detailed performance analysis',
              status: 'success',
              performance: {
                processedProducts: enrichedProducts.length,
                apiCalls: performanceMetrics.apiCalls.total,
                method: 'API Mesh',
                executionTime: executionTime,
                // Flattened performance data
                totalTime: executionTime + 'ms',
                productFetch: performanceMetrics.timing.productFetch,
                dataExtraction: performanceMetrics.timing.dataExtraction,
                parallelFetch: performanceMetrics.timing.parallelFetch,
                dataEnrichment: performanceMetrics.timing.dataEnrichment,
                productsApiCalls: performanceMetrics.apiCalls.products,
                categoriesApiCalls: performanceMetrics.apiCalls.categories,
                inventoryApiCalls: performanceMetrics.apiCalls.inventory,
                totalApiCalls: performanceMetrics.apiCalls.total,
                uniqueCategories: Array.from(categoryIds).length,
                productCount: allProducts.length,
                skuCount: skus.length,
              },
            };
          } catch (error) {
            return {
              products: [],
              total_count: 0,
              message: 'Error: ' + error.message,
              status: 'error',
              performance: {
                processedProducts: 0,
                apiCalls: performanceMetrics.apiCalls.total,
                method: 'API Mesh',
                executionTime: Date.now() - startTime,
                breakdown: {
                  error: error.message,
                  partialMetrics: performanceMetrics,
                },
              },
            };
          }
        },
      },
    },
  },
};

/**
 * Transforms a media gallery entry into a simplified image object.
 * Based on src/commerce/transform/product.js transformImageEntry function
 * @private
 * @param {Object} img - Media gallery entry from Adobe Commerce
 * @param {string} img.file - Image file path
 * @param {number} img.position - Image position/order
 * @param {Array<string>} [img.types] - Image type/role identifiers
 * @returns {Object} Simplified image object
 */
function transformImageEntry(img) {
  // Determine the appropriate URL
  let url;
  if (img.url) {
    // Use the provided URL if available
    url = img.url;
  } else if (img.file && img.file.startsWith('http')) {
    // If file is already a full URL, use it directly
    url = img.file;
  } else {
    // Construct catalog URL for relative paths
    url = 'catalog/product' + img.file;
  }

  const imageObj = {
    filename: img.file,
    url: url,
    position: img.position,
  };
  if (img.types && img.types.length > 0) {
    imageObj.roles = img.types;
  }
  return imageObj;
}

/**
 * In-memory category cache for resolver execution
 * OPTIMIZATION: Prevents redundant category lookups within single request
 */
const categoryCache = new Map();

/**
 * Fetch category data using direct REST API calls with performance tracking
 * OPTIMIZATION: Uses in-memory caching to avoid redundant lookups
 */
async function fetchCategoriesFromSource(context, categoryIds, performanceMetrics) {
  const stepStart = Date.now();
  const categoryMap = {};

  // Check cache first - OPTIMIZATION
  const uncachedCategoryIds = [];
  categoryIds.forEach((categoryId) => {
    if (categoryCache.has(categoryId)) {
      categoryMap[categoryId] = categoryCache.get(categoryId);
    } else {
      uncachedCategoryIds.push(categoryId);
    }
  });

  // Only fetch uncached categories
  if (uncachedCategoryIds.length === 0) {
    // All categories were cached - no API calls needed!
    return categoryMap;
  }

  // Get admin token from context headers
  const adminToken = context.headers['x-commerce-admin-token'];
  if (!adminToken) {
    throw new Error('Admin token required in x-commerce-admin-token header');
  }

  // Use existing Commerce configuration
  const commerceBaseUrl = 'https://citisignal-com774.adobedemo.com';

  // Individual category fetching with caching optimization
  const meshConfig = {
    pagination: {
      defaultPageSize: 150,
      maxPages: 25,
    },
    batching: {
      categories: 20,
      inventory: 20,
      maxConcurrent: 10,
      requestDelay: 100,
    },
    timeout: 30000,
    retries: 3,
  };
  const batchSize = meshConfig.batching.categories;
  const maxConcurrent = meshConfig.batching.maxConcurrent || 15;

  for (let i = 0; i < uncachedCategoryIds.length; i += batchSize) {
    const batch = uncachedCategoryIds.slice(i, i + batchSize);

    const categoryPromises = batch.slice(0, maxConcurrent).map(async (categoryId) => {
      try {
        const url = commerceBaseUrl + '/rest/V1/categories/' + categoryId;
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            Authorization: 'Bearer ' + adminToken,
            'Content-Type': 'application/json',
            // HTTP OPTIMIZATION: Connection and compression headers
            Connection: 'keep-alive',
            'Accept-Encoding': 'gzip, deflate, br',
            'Cache-Control': 'no-cache',
            'User-Agent': 'Adobe-App-Builder-Mesh/1.0',
          },
        });

        performanceMetrics.apiCalls.categories++;

        if (response.ok) {
          const category = await response.json();
          if (category && category.name) {
            // Store in both cache and result map
            categoryCache.set(categoryId, category.name);
            categoryMap[categoryId] = category.name;
          }
        }
      } catch (error) {
        console.warn('Failed to fetch category ' + categoryId + ': ' + error.message);
      }
    });

    await Promise.all(categoryPromises);
  }

  return categoryMap;
}

/**
 * Fetch inventory data using BULK REST API calls with performance tracking
 * OPTIMIZATION: Uses 'in' condition to fetch multiple SKUs in single calls
 */
async function fetchInventoryFromSource(context, skus, performanceMetrics) {
  const stepStart = Date.now();
  const inventoryMap = {};

  // Get admin token from context headers
  const adminToken = context.headers['x-commerce-admin-token'];
  if (!adminToken) {
    throw new Error('Admin token required in x-commerce-admin-token header');
  }

  // Use existing Commerce configuration
  const commerceBaseUrl = 'https://citisignal-com774.adobedemo.com';

  // BULK OPTIMIZATION: Use larger batch sizes for 'in' condition
  const bulkBatchSize = 40; // REVERTED: Back to 40 to avoid extra API call
  const maxConcurrent = 3; // Limit concurrent bulk calls

  // Split SKUs into batches for bulk processing
  const batches = [];
  for (let i = 0; i < skus.length; i += bulkBatchSize) {
    batches.push(skus.slice(i, i + bulkBatchSize));
  }

  // Process batches with controlled concurrency
  for (let i = 0; i < batches.length; i += maxConcurrent) {
    const currentBatches = batches.slice(i, i + maxConcurrent);

    const batchPromises = currentBatches.map(async (batch) => {
      const apiCallStart = Date.now();

      try {
        // BULK OPTIMIZATION: Use 'in' condition for multiple SKUs in single call
        const skuList = batch.join(',');
        const queryParams = new URLSearchParams({
          'searchCriteria[filter_groups][0][filters][0][field]': 'sku',
          'searchCriteria[filter_groups][0][filters][0][value]': skuList,
          'searchCriteria[filter_groups][0][filters][0][condition_type]': 'in',
          'searchCriteria[pageSize]': batch.length.toString(),
        });

        const url = commerceBaseUrl + '/rest/V1/stockItems?' + queryParams.toString();

        const response = await fetch(url, {
          method: 'GET',
          headers: {
            Authorization: 'Bearer ' + adminToken,
            'Content-Type': 'application/json',
            // HTTP OPTIMIZATION: Connection and compression headers
            Connection: 'keep-alive',
            'Accept-Encoding': 'gzip, deflate, br',
            'Cache-Control': 'no-cache',
            'User-Agent': 'Adobe-App-Builder-Mesh/1.0',
          },
        });

        performanceMetrics.apiCalls.inventory++;

        if (response.ok) {
          // RESPONSE OPTIMIZATION: Efficient JSON parsing with error handling
          let result;
          try {
            result = await response.json();
          } catch (jsonError) {
            throw new Error('Failed to parse inventory response JSON: ' + jsonError.message);
          }

          if (result && result.items && result.items.length > 0) {
            // Process all returned stock items
            result.items.forEach((stockItem) => {
              if (stockItem.sku) {
                inventoryMap[stockItem.sku] = {
                  qty: stockItem.qty || 0,
                  is_in_stock: stockItem.is_in_stock || false,
                };
              }
            });
          }

          // Set defaults for any SKUs not returned
          batch.forEach((sku) => {
            if (!inventoryMap[sku]) {
              inventoryMap[sku] = { qty: 0, is_in_stock: false };
            }
          });
        } else {
          // Default inventory for failed lookups
          batch.forEach((sku) => {
            inventoryMap[sku] = { qty: 0, is_in_stock: false };
          });
        }
      } catch (error) {
        // Default inventory for failed lookups
        batch.forEach((sku) => {
          inventoryMap[sku] = { qty: 0, is_in_stock: false };
        });
      }
    });

    await Promise.all(batchPromises);
  }

  return inventoryMap;
}

/**
 * Fetch all products using direct REST API calls with performance tracking
 * OPTIMIZATION: Uses parallel page fetching for better performance
 */
async function fetchAllProductsFromSource(context, pageSize, maxPages, performanceMetrics) {
  const stepStart = Date.now();
  const allProducts = [];

  // Get admin token from context headers
  const adminToken = context.headers['x-commerce-admin-token'];
  if (!adminToken) {
    throw new Error('Admin token required in x-commerce-admin-token header');
  }

  // Use existing Commerce configuration
  const commerceBaseUrl = 'https://citisignal-com774.adobedemo.com';

  // OPTIMIZATION: First fetch to determine total pages
  const firstPageResponse = await fetchProductPage(
    1,
    pageSize,
    adminToken,
    commerceBaseUrl,
    performanceMetrics
  );

  if (!firstPageResponse || !firstPageResponse.items) {
    return allProducts;
  }

  allProducts.push(...firstPageResponse.items);
  const totalPages = Math.min(Math.ceil(firstPageResponse.total_count / pageSize), maxPages);

  // OPTIMIZATION: If multiple pages needed, fetch remaining pages in parallel
  if (totalPages > 1) {
    const remainingPages = [];
    for (let page = 2; page <= totalPages; page++) {
      remainingPages.push(page);
    }

    // Fetch remaining pages in parallel with concurrency limit
    const maxConcurrentPages = 3; // REVERTED: Back to 3 for optimal performance

    for (let i = 0; i < remainingPages.length; i += maxConcurrentPages) {
      const pageBatch = remainingPages.slice(i, i + maxConcurrentPages);

      const batchPromises = pageBatch.map((page) =>
        fetchProductPage(page, pageSize, adminToken, commerceBaseUrl, performanceMetrics)
      );

      const batchResults = await Promise.all(batchPromises);

      // Add results from this batch
      batchResults.forEach((result) => {
        if (result && result.items) {
          allProducts.push(...result.items);
        }
      });
    }
  }

  return allProducts;
}

/**
 * Helper function to fetch a single page of products
 * OPTIMIZATION: Enhanced with HTTP connection optimization
 */
async function fetchProductPage(page, pageSize, adminToken, commerceBaseUrl, performanceMetrics) {
  const apiCallStart = Date.now();

  // FIELD OPTIMIZATION: Only fetch fields actually used in final output
  // Reverted custom attributes filtering to ensure category data is available
  const queryParams = new URLSearchParams({
    'searchCriteria[pageSize]': pageSize,
    'searchCriteria[currentPage]': page,
    fields: 'items[sku,name,price,categories,media_gallery_entries,custom_attributes],total_count',
  });

  const url = commerceBaseUrl + '/rest/V1/products?' + queryParams.toString();

  const response = await fetch(url, {
    method: 'GET',
    headers: {
      Authorization: 'Bearer ' + adminToken,
      'Content-Type': 'application/json',
      // HTTP OPTIMIZATION: Connection and compression headers
      Connection: 'keep-alive',
      'Accept-Encoding': 'gzip, deflate, br',
      'Cache-Control': 'no-cache',
      'User-Agent': 'Adobe-App-Builder-Mesh/1.0',
    },
  });

  performanceMetrics.apiCalls.products++;

  if (!response.ok) {
    throw new Error('Products API request failed: ' + response.status + ' ' + response.statusText);
  }

  // RESPONSE OPTIMIZATION: Efficient JSON parsing with error handling
  try {
    return await response.json();
  } catch (jsonError) {
    throw new Error('Failed to parse product response JSON: ' + jsonError.message);
  }
}
