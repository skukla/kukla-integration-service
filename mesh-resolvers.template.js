/* GENERATION_METADATA: {"templateHash":"dd2969d8d7b29e0bb047422f60c177457ad1dc48d3cc6ebc221abbd09ae7b3ee","configHash":"f9b465e5b2e75c29ed4e701d3bd084d7827f8aa545ab3123626de7668748d184","generatedAt":"2025-06-30T00:53:26.971Z","version":"1.0.0"} */
/**
 * API Mesh Resolvers - Domain-Driven Architecture
 * Auto-generated by scripts/generate-mesh-resolver.js
 *
 * Applies domain-driven design patterns within mesh resolver constraints.
 * Mirrors our action architecture: utils -> operations -> workflows -> resolver
 *
 * NOTE: Cannot use require() in mesh environment, so all code is embedded.
 * Organization follows our src/commerce patterns for consistency.
 */

// =============================================================================
// CONFIGURATION & CONSTANTS
// =============================================================================

/**
 * Mesh configuration injected during generation
 * Mirrors our config/domains approach
 */
const meshConfig = __MESH_CONFIG__;

/**
 * Commerce base URL from configuration
 * Follows our configuration management patterns
 */
const commerceBaseUrl = '{{{COMMERCE_BASE_URL}}}';

/**
 * Cache TTL configuration
 * Mirrors our performance configuration approach
 */
const CACHE_TTL = parseInt('{{{MESH_CACHE_TTL}}}');

// =============================================================================
// UTILS DOMAIN - Low-level pure functions
// =============================================================================

/**
 * Cache Utilities
 * Mirrors our src/files/utils/cache.js patterns
 */
const categoryCache = new Map();

/**
 * Get cached category data
 * Pure function following our caching patterns
 * @param {string} categoryId - Category ID
 * @returns {Object|null} Cached category data or null
 */
function getCachedCategory(categoryId) {
  const cached = categoryCache.get(categoryId);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.data;
  }
  if (cached) {
    categoryCache.delete(categoryId);
  }
  return null;
}

/**
 * Cache category data
 * Pure function following our caching patterns
 * @param {string} categoryId - Category ID
 * @param {Object} data - Category data
 */
function cacheCategory(categoryId, data) {
  categoryCache.set(categoryId, {
    timestamp: Date.now(),
    data: data,
  });
}

/**
 * Build category map from cache
 * Composition function following our utils patterns
 * @param {string[]} categoryIds - Array of category IDs
 * @returns {Object} Category map from cache
 */
function buildCategoryMapFromCache(categoryIds) {
  const categoryMap = {};
  categoryIds.forEach((id) => {
    const cached = getCachedCategory(id);
    if (cached) {
      categoryMap[id] = cached;
    }
  });
  return categoryMap;
}

/**
 * Authentication Utilities
 * Mirrors our src/commerce/utils/oauth.js patterns
 */

/**
 * Percent encoding for OAuth (RFC 3986)
 * Pure function following our encoding patterns
 * @param {string} str - String to encode
 * @returns {string} Percent-encoded string
 */
function percentEncode(str) {
  if (str === null || str === undefined) return '';
  return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Generate HMAC-SHA256 signature using Web Crypto API
 * Pure function following our crypto patterns
 * @param {string} key - Signing key
 * @param {string} data - Data to sign
 * @returns {Promise<string>} Base64-encoded signature
 * @throws {Error} If signature generation fails
 */
async function generateHmacSignature(key, data) {
  try {
    // Convert strings to ArrayBuffer
    const keyBuffer = new TextEncoder().encode(key);
    const dataBuffer = new TextEncoder().encode(data);

    // Import the key for HMAC
    const cryptoKey = await crypto.subtle.importKey(
      'raw',
      keyBuffer,
      {
        name: 'HMAC',
        hash: 'SHA-256',
      },
      false,
      ['sign']
    );

    // Generate signature
    const signatureBuffer = await crypto.subtle.sign('HMAC', cryptoKey, dataBuffer);

    // Convert to base64
    const signatureArray = new Uint8Array(signatureBuffer);
    let binaryString = '';
    for (let i = 0; i < signatureArray.length; i++) {
      binaryString += String.fromCharCode(signatureArray[i]);
    }

    return btoa(binaryString);
  } catch (error) {
    throw new Error('Failed to generate HMAC signature: ' + error.message);
  }
}

/**
 * Create OAuth 1.0 authorization header
 * Mirrors our src/commerce/utils/oauth.js implementation
 * @param {Object} oauthParams - OAuth parameters
 * @param {string} oauthParams.consumerKey - Consumer key
 * @param {string} oauthParams.consumerSecret - Consumer secret
 * @param {string} oauthParams.accessToken - Access token
 * @param {string} oauthParams.accessTokenSecret - Access token secret
 * @param {string} method - HTTP method
 * @param {string} url - Request URL
 * @returns {Promise<string>} OAuth authorization header
 * @throws {Error} If OAuth credentials are missing or invalid
 */
async function createOAuthHeader(oauthParams, method, url) {
  const { consumerKey, consumerSecret, accessToken, accessTokenSecret } = oauthParams;

  // OAuth 1.0 parameters (following our patterns)
  const timestamp = Math.floor(Date.now() / 1000).toString();
  const nonce = Array.from(crypto.getRandomValues(new Uint8Array(16)), (b) =>
    b.toString(16).padStart(2, '0')
  ).join('');

  // Parse URL to get base URL and parameters (Postman-style like our implementation)
  const urlObj = new URL(url);
  const baseUrl = urlObj.protocol + '//' + urlObj.host + urlObj.pathname;

  // Collect OAuth parameters
  const oauthSignatureParams = {
    oauth_consumer_key: consumerKey,
    oauth_token: accessToken,
    oauth_signature_method: 'HMAC-SHA256',
    oauth_timestamp: timestamp,
    oauth_nonce: nonce,
    oauth_version: '1.0',
  };

  // Collect query parameters
  const queryParams = {};
  for (const [key, value] of urlObj.searchParams) {
    queryParams[key] = value;
  }

  // Combine all parameters for signature base
  const allParams = { ...oauthSignatureParams, ...queryParams };

  // Create parameter string (percent encode keys and values, then sort)
  const parameterString = Object.keys(allParams)
    .sort()
    .map((key) => percentEncode(key) + '=' + percentEncode(allParams[key]))
    .join('&');

  // Create signature base string
  const signatureBaseString =
    method.toUpperCase() + '&' + percentEncode(baseUrl) + '&' + percentEncode(parameterString);

  // Create signing key
  const signingKey = percentEncode(consumerSecret) + '&' + percentEncode(accessTokenSecret);

  // Generate HMAC-SHA256 signature
  const signature = await generateHmacSignature(signingKey, signatureBaseString);

  // Add signature to OAuth parameters
  oauthSignatureParams.oauth_signature = signature;

  // Create Authorization header
  const headerParams = Object.keys(oauthSignatureParams)
    .sort()
    .map((key) => percentEncode(key) + '="' + percentEncode(oauthSignatureParams[key]) + '"')
    .join(', ');

  return 'OAuth ' + headerParams;
}

/**
 * Data Extraction Utilities
 * Mirrors our src/products/utils/data.js patterns
 */

/**
 * Extract OAuth credentials from context headers
 * Pure function following our credential extraction patterns
 * @param {Object} context - GraphQL context
 * @returns {Object} OAuth credentials object
 * @throws {Error} If required credentials are missing
 */
function extractOAuthCredentials(context) {
  const oauthParams = {
    consumerKey: context.headers['x-commerce-consumer-key'],
    consumerSecret: context.headers['x-commerce-consumer-secret'],
    accessToken: context.headers['x-commerce-access-token'],
    accessTokenSecret: context.headers['x-commerce-access-token-secret'],
  };

  if (
    !oauthParams.consumerKey ||
    !oauthParams.consumerSecret ||
    !oauthParams.accessToken ||
    !oauthParams.accessTokenSecret
  ) {
    throw new Error(
      'OAuth credentials required in headers: x-commerce-consumer-key, x-commerce-consumer-secret, x-commerce-access-token, x-commerce-access-token-secret'
    );
  }

  return oauthParams;
}

/**
 * Extract category IDs and SKUs from products
 * Mirrors our src/products/utils/category.js extraction patterns
 * @param {Array} products - Array of product objects
 * @returns {Object} Object with categoryIds Set and skus Array
 */
function extractProductIdentifiers(products) {
  const categoryIds = new Set();
  const skus = [];

  products.forEach((product) => {
    // Extract SKUs
    if (product.sku) {
      skus.push(product.sku);
    }

    // Extract category IDs from custom attributes
    if (product.custom_attributes && Array.isArray(product.custom_attributes)) {
      product.custom_attributes.forEach((attr) => {
        if (attr.attribute_code === 'category_ids' && attr.value) {
          try {
            const ids = Array.isArray(attr.value) ? attr.value : attr.value.split(',');
            ids.forEach((id) => categoryIds.add(id.toString()));
          } catch (e) {
            // Skip invalid category IDs
          }
        }
      });
    }
  });

  return { categoryIds, skus };
}

/**
 * Enrich products with category and inventory data
 * Pure function following our enrichment patterns
 * @param {Array} products - Array of products
 * @param {Object} categoryMap - Category data map
 * @param {Object} inventoryMap - Inventory data map
 * @returns {Array} Enriched products
 */
function enrichProductsWithData(products, categoryMap, inventoryMap) {
  return products.map((product) => {
    const sku = product.sku;
    const inventory = inventoryMap[sku] || { qty: 0, is_in_stock: false };

    // Extract category objects from custom attributes
    let categoryObjects = [];
    if (product.custom_attributes && Array.isArray(product.custom_attributes)) {
      product.custom_attributes.forEach((attr) => {
        if (attr.attribute_code === 'category_ids' && attr.value) {
          try {
            const ids = Array.isArray(attr.value) ? attr.value : attr.value.split(',');
            categoryObjects = ids
              .map((id) => categoryMap[id.toString()])
              .filter((cat) => cat)
              .map((cat) => ({ id: cat.id, name: cat.name }));
          } catch (e) {
            // Skip invalid category data
          }
        }
      });
    }

    // Sort media_gallery_entries to prioritize AEM URLs
    let sortedMediaGallery = [];
    if (product.media_gallery_entries && Array.isArray(product.media_gallery_entries)) {
      sortedMediaGallery = [...product.media_gallery_entries].sort((a, b) => {
        const aIsUrl = a.file && a.file.startsWith('http');
        const bIsUrl = b.file && b.file.startsWith('http');

        // AEM URLs (starting with http) should come first
        if (aIsUrl && !bIsUrl) return -1;
        if (!aIsUrl && bIsUrl) return 1;

        // If both are URLs or both are paths, maintain original order
        return 0;
      });
    }

    // Return RAW consolidated data - let buildProducts step handle transformation
    return {
      ...product,
      qty: inventory.qty,
      categories: categoryObjects, // Raw category objects with id/name
      inventory: inventory,
      media_gallery_entries: sortedMediaGallery, // AEM URLs prioritized over catalog paths
    };
  });
}

// =============================================================================
// OPERATIONS DOMAIN - Mid-level business processes
// =============================================================================

/**
 * Data Fetching Operations
 * Mirrors our src/commerce/operations/api-requests.js patterns
 */

/**
 * Fetch all products from Commerce API with pagination
 * Business operation that coordinates product fetching
 * @param {Object} context - GraphQL context
 * @param {number} pageSize - Items per page
 * @param {number} maxPages - Maximum pages to fetch
 * @param {Object} [performance] - Performance tracking object
 * @returns {Promise<Array>} Array of products
 * @throws {Error} If product fetching fails
 */
async function fetchAllProductsFromSource(context, pageSize, maxPages, performance = null) {
  const allProducts = [];
  let currentPage = 1;

  // Extract OAuth credentials (validates automatically)
  const oauthParams = extractOAuthCredentials(context);

  try {
    while (currentPage <= maxPages) {
      const url =
        commerceBaseUrl +
        '/rest/V1/products?searchCriteria[pageSize]=' +
        pageSize +
        '&searchCriteria[currentPage]=' +
        currentPage +
        '&fields=items[id,sku,name,price,status,type_id,attribute_set_id,created_at,updated_at,weight,categories,media_gallery_entries[file,url,position,types],custom_attributes],total_count';

      const authHeader = await createOAuthHeader(oauthParams, 'GET', url);

      // Track API call
      if (performance) {
        performance.productsApiCalls++;
        performance.totalApiCalls++;
      }

      const response = await fetch(url, {
        method: 'GET',
        headers: {
          Authorization: authHeader,
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        throw new Error(
          'Products API request failed: ' + response.status + ' ' + response.statusText
        );
      }

      const data = await response.json();

      if (!data.items || !Array.isArray(data.items)) {
        break;
      }

      allProducts.push(...data.items);

      // Check if we should continue pagination
      if (
        data.items.length < pageSize ||
        !data.total_count ||
        allProducts.length >= data.total_count
      ) {
        break;
      }

      currentPage++;
    }

    return allProducts;
  } catch (error) {
    throw new Error('Failed to fetch products: ' + error.message);
  }
}

/**
 * Fetch category data from Commerce API in batches
 * Business operation that coordinates category data fetching with caching
 * @param {Object} context - GraphQL context
 * @param {Array} categoryIds - Array of category IDs
 * @param {Object} [performance] - Performance tracking object
 * @returns {Promise<Object>} Category map
 * @throws {Error} If category fetching fails
 */
async function fetchCategoriesFromSource(context, categoryIds, performance = null) {
  const categoryMap = {};
  const batchSize = meshConfig.batching.categories;

  if (categoryIds.length === 0) {
    return categoryMap;
  }

  // Step 1: Check cache first (optimization)
  const cachedCategories = buildCategoryMapFromCache(categoryIds);
  Object.assign(categoryMap, cachedCategories);

  // Step 2: Filter out already cached categories
  const uncachedIds = categoryIds.filter((id) => !getCachedCategory(id));

  // Track cache performance
  const cachedCount = categoryIds.length - uncachedIds.length;
  if (performance) {
    performance.categoriesCached = cachedCount;
    performance.categoriesFetched = uncachedIds.length;
  }

  if (uncachedIds.length === 0) {
    // All categories were cached - 0 API calls needed!
    console.log('All', categoryIds.length, 'categories served from cache - 0 API calls');
    return categoryMap;
  }

  console.log('Cache hit for', cachedCount, 'categories, fetching', uncachedIds.length, 'from API');

  // Step 3: Fetch uncached categories
  const oauthParams = extractOAuthCredentials(context);

  try {
    // Process uncached categories in batches
    for (let i = 0; i < uncachedIds.length; i += batchSize) {
      const batch = uncachedIds.slice(i, i + batchSize);

      const promises = batch.map(async (categoryId) => {
        const url = commerceBaseUrl + '/rest/V1/categories/' + categoryId;
        const authHeader = await createOAuthHeader(oauthParams, 'GET', url);

        // Track API call
        if (performance) {
          performance.categoriesApiCalls++;
          performance.totalApiCalls++;
        }

        const response = await fetch(url, {
          method: 'GET',
          headers: {
            Authorization: authHeader,
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          console.warn('Category ' + categoryId + ' fetch failed: ' + response.status);
          return null;
        }

        const category = await response.json();

        // Cache the fetched category
        cacheCategory(categoryId, category);

        return { id: categoryId, data: category };
      });

      const results = await Promise.all(promises);

      results.forEach((result) => {
        if (result && result.data) {
          categoryMap[result.id] = result.data;
        }
      });
    }

    return categoryMap;
  } catch (error) {
    throw new Error('Failed to fetch categories: ' + error.message);
  }
}

/**
 * Authentication Operations
 * Mirrors our src/commerce/operations/authentication.js patterns
 */

/**
 * Get admin Bearer token using username/password authentication
 * Business operation for admin token acquisition
 * @param {Object} context - GraphQL context with admin credentials
 * @param {Object} [performance] - Performance tracking object
 * @returns {Promise<string>} Bearer token
 * @throws {Error} If authentication fails
 */
async function getAdminToken(context, performance = null) {
  const username = context.adminCredentials?.username;
  const password = context.adminCredentials?.password;

  if (!username || !password) {
    throw new Error(
      'Admin credentials required for inventory: adminUsername and adminPassword GraphQL variables'
    );
  }

  const tokenUrl = '{{{COMMERCE_BASE_URL}}}' + '/rest/all/V1/integration/admin/token';

  // Track API call
  if (performance) {
    performance.inventoryApiCalls++;
    performance.totalApiCalls++;
  }

  const response = await fetch(tokenUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ username, password }),
  });

  if (!response.ok) {
    throw new Error('Failed to get admin token: ' + response.status + ' ' + response.statusText);
  }

  const token = await response.json();
  return token; // Returns the bearer token string
}

/**
 * Fetch inventory data from Commerce API in batches
 * Business operation that coordinates inventory data fetching
 * @param {Object} context - GraphQL context
 * @param {Array} skus - Array of SKUs
 * @param {Object} [performance] - Performance tracking object
 * @returns {Promise<Object>} Inventory map
 * @throws {Error} If inventory fetching fails
 */
async function fetchInventoryFromSource(context, skus, performance = null) {
  const inventoryMap = {};

  try {
    // Step 1: Get Bearer token authentication for inventory
    const bearerToken = await getAdminToken(context, performance);
    const batchSize = meshConfig.batching.inventory;

    console.log('Fetching inventory for', skus.length, 'SKUs with Bearer token');

    // Step 2: Process SKUs in batches
    for (let i = 0; i < skus.length; i += batchSize) {
      const batch = skus.slice(i, i + batchSize);

      // Use same format as working REST API
      const searchCriteria = {
        filterGroups: [
          {
            filters: [
              {
                field: 'sku',
                value: batch.join(','),
                conditionType: 'in',
              },
            ],
          },
        ],
      };

      const queryParams = new URLSearchParams({
        searchCriteria: JSON.stringify(searchCriteria),
      });

      const url =
        '{{{COMMERCE_BASE_URL}}}' + '/rest/all/V1/inventory/source-items?' + queryParams.toString();

      console.log('Calling inventory API:', url.substring(0, 100) + '...');

      // Track API call
      if (performance) {
        performance.inventoryApiCalls++;
        performance.totalApiCalls++;
      }

      const response = await fetch(url, {
        method: 'GET',
        headers: {
          Authorization: 'Bearer ' + bearerToken,
          'Content-Type': 'application/json',
        },
      });

      console.log('Inventory API response status:', response.status);

      if (!response.ok) {
        const errorText = await response.text();
        console.warn(
          'Inventory batch fetch failed: ' +
            response.status +
            ' ' +
            response.statusText +
            ' - ' +
            errorText
        );
        continue;
      }

      const data = await response.json();
      console.log('Inventory API returned', data.items?.length || 0, 'items');

      if (data.items && Array.isArray(data.items)) {
        data.items.forEach((item) => {
          if (item.sku) {
            console.log('Inventory for', item.sku, ':', item.quantity);
            inventoryMap[item.sku] = {
              qty: item.quantity || 0,
              is_in_stock: item.status === 1,
            };
          }
        });
      }
    }

    console.log('Final inventory map has', Object.keys(inventoryMap).length, 'entries');
    return inventoryMap;
  } catch (error) {
    console.error('Inventory fetch error:', error);
    throw new Error('Failed to fetch inventory: ' + error.message);
  }
}

// =============================================================================
// WORKFLOWS DOMAIN - High-level orchestration
// =============================================================================

/**
 * Product Enrichment Workflow
 * Mirrors our src/products/workflows/mesh-export.js patterns
 */

/**
 * Calculate dynamic performance metrics
 * Business function that computes mesh efficiency metrics
 * @param {Object} performance - Performance tracking object
 * @param {Set} categoryIds - Category IDs set
 * @param {Array} skus - SKUs array
 * @param {number} startTime - Start timestamp
 * @returns {Object} Enhanced performance metrics
 */
function calculatePerformanceMetrics(performance, categoryIds, skus, startTime) {
  const endTime = Date.now();
  performance.executionTime = (endTime - startTime) / 1000; // Convert to seconds
  performance.productCount = performance.processedProducts;
  performance.skuCount = skus.length;
  performance.uniqueCategories = categoryIds.size;

  // Calculate dynamic client-perspective efficiency metrics
  let sourcesUsed = 0;
  if (performance.productsApiCalls > 0) sourcesUsed++; // Products API
  if (performance.categoriesApiCalls > 0 || performance.categoriesCached > 0) sourcesUsed++; // Categories API/Cache
  if (performance.inventoryApiCalls > 0) sourcesUsed++; // Inventory API
  performance.dataSourcesUnified = sourcesUsed;

  // Calculate actual mesh consolidation ratio
  const actualMeshCalls = performance.totalApiCalls || performance.apiCalls;
  performance.queryConsolidation = actualMeshCalls + ':1';

  // Calculate actual cache hit rate
  if (performance.categoriesCached + performance.categoriesFetched > 0) {
    performance.cacheHitRate = Math.round(
      (performance.categoriesCached /
        (performance.categoriesCached + performance.categoriesFetched)) *
        100
    );
  }

  // Populate mesh optimizations based on actual execution
  performance.meshOptimizations = [];
  if (performance.categoriesCached > 0) {
    performance.meshOptimizations.push('Category Caching');
  }
  if (performance.dataSourcesUnified > 1) {
    performance.meshOptimizations.push('Multi-API Consolidation');
  }
  if (performance.categoriesApiCalls > 0 && performance.inventoryApiCalls > 0) {
    performance.meshOptimizations.push('Parallel Data Fetching');
  }
  if (performance.queryConsolidation && performance.queryConsolidation !== '1:1') {
    performance.meshOptimizations.push('Query Consolidation');
  }

  return performance;
}

/**
 * Initialize performance tracking
 * Pure function that creates performance tracking object
 * @returns {Object} Performance tracking object
 */
function initializePerformanceTracking() {
  return {
    // Traditional metrics (for comparison)
    processedProducts: 0,
    apiCalls: 0,
    productsApiCalls: 0,
    categoriesApiCalls: 0,
    inventoryApiCalls: 0,
    totalApiCalls: 0,
    uniqueCategories: 0,
    productCount: 0,
    skuCount: 0,
    method: 'API Mesh',
    executionTime: 0,

    // Client-perspective efficiency metrics (calculated dynamically)
    clientCalls: 1, // Client makes only 1 GraphQL query (always true)
    dataSourcesUnified: 0, // Will be calculated based on actual APIs called
    queryConsolidation: null, // Will be calculated as "X:1" ratio
    cacheHitRate: 0, // Percentage of cached categories
    categoriesCached: 0, // Number of categories served from cache
    categoriesFetched: 0, // Number of categories fetched from API

    // Mesh advantages (calculated dynamically)
    operationComplexity: 'single-query', // Always true for GraphQL mesh
    dataFreshness: 'real-time', // Mesh gets fresh data
    clientComplexity: 'minimal', // Client sends 1 query vs orchestrating multiple
    apiOrchestration: 'automated', // Mesh handles all coordination
    parallelization: 'automatic', // Mesh handles parallel data fetching
    meshOptimizations: [], // Will be populated with actual optimizations used
  };
}

// =============================================================================
// MAIN RESOLVER - Step-based orchestration
// =============================================================================

/**
 * Main mesh products resolver
 * Follows our action step-based pattern for consistency
 */
module.exports = {
  resolvers: {
    Query: {
      mesh_products_enriched: {
        resolve: async (parent, args, context) => {
          try {
            const startTime = Date.now();
            const pageSize = args.pageSize || meshConfig.pagination.defaultPageSize;
            const maxPages = meshConfig.pagination.maxPages;

            // Initialize performance tracking (mirrors our action patterns)
            const performance = initializePerformanceTracking();

            // Store admin credentials from GraphQL arguments (Step 0: Context Setup)
            context.adminCredentials = {
              username: args.adminUsername,
              password: args.adminPassword,
            };

            // STEP 1: Fetch all products (mirrors fetchProducts operation)
            const allProducts = await fetchAllProductsFromSource(
              context,
              pageSize,
              maxPages,
              performance
            );

            // STEP 2: Extract category IDs and SKUs (mirrors our extraction patterns)
            const { categoryIds, skus } = extractProductIdentifiers(allProducts);

            // STEP 3: Fetch category and inventory data in parallel (mirrors enrichment operations)
            const [categoryMap, inventoryMap] = await Promise.all([
              fetchCategoriesFromSource(context, Array.from(categoryIds), performance),
              fetchInventoryFromSource(context, skus, performance),
            ]);

            // STEP 4: Enrich products with consolidated data (mirrors buildProducts pattern)
            const enrichedProducts = enrichProductsWithData(allProducts, categoryMap, inventoryMap);

            // STEP 5: Calculate final performance metrics (mirrors our tracing patterns)
            performance.processedProducts = enrichedProducts.length;
            const finalPerformance = calculatePerformanceMetrics(
              performance,
              categoryIds,
              skus,
              startTime
            );

            // Return structured response (mirrors our response patterns)
            return {
              products: enrichedProducts,
              total_count: enrichedProducts.length,
              message:
                'Successfully fetched ' +
                enrichedProducts.length +
                ' products with category and inventory data',
              status: 'success',
              performance: finalPerformance,
            };
          } catch (error) {
            console.error('Mesh resolver error:', error);
            throw new Error('Failed to fetch enriched products: ' + error.message);
          }
        },
      },
    },
  },
};
