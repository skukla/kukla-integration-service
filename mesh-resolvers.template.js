/* eslint-disable */
/**
 * API Mesh Resolvers - True Mesh Pattern
 * Auto-generated by scripts/generate-mesh-resolver.js
 *
 * This implementation uses the configured Commerce REST API source
 * with admin token authentication via operationHeaders.
 */

module.exports = {
  resolvers: {
    Query: {
      mesh_products_enriched: {
        resolve: async (parent, args, context) => {
          const startTime = Date.now();

          try {
            // Get admin token from headers (will be passed to operationHeaders)
            const adminToken = context.headers['x-commerce-admin-token'];

            if (!adminToken) {
              throw new Error('Admin token required via x-commerce-admin-token header');
            }

            // Configuration from injected config
            const meshConfig = __MESH_CONFIG__;
            const pageSize = args.pageSize || meshConfig.pagination.defaultPageSize;
            const maxPages = args.maxPages || meshConfig.pagination.maxPages;

            // Step 1: Fetch all products using the configured Commerce REST API source
            const allProducts = await fetchAllProductsFromSource(context, pageSize, maxPages);

            // Step 2: Extract unique category IDs and SKUs
            const categoryIds = new Set();
            const skus = [];

            allProducts.forEach((product) => {
              skus.push(product.sku);

              // Extract category IDs from various locations
              if (Array.isArray(product.category_ids)) {
                product.category_ids.forEach((id) => categoryIds.add(String(id)));
              }

              if (Array.isArray(product.custom_attributes)) {
                product.custom_attributes.forEach((attr) => {
                  if (attr.attribute_code === 'category_ids' && Array.isArray(attr.value)) {
                    attr.value.forEach((id) => categoryIds.add(String(id)));
                  }
                });
              }
            });

            // Step 3: Fetch category data and inventory data using configured source
            const [categoryMap, inventoryMap] = await Promise.all([
              fetchCategoriesFromSource(context, Array.from(categoryIds)),
              fetchInventoryFromSource(context, skus),
            ]);

            // Step 4: Enrich products with category, inventory, and image data (RAW DATA)
            const enrichedProducts = allProducts.map((product) => {
              // Get inventory data
              const inventory = inventoryMap[product.sku] || { qty: 0, is_in_stock: false };

              // Add inventory to product as qty field for compatibility
              const enrichedProduct = {
                ...product,
                qty: inventory.qty,
                inventory: {
                  qty: inventory.qty,
                  is_in_stock: inventory.is_in_stock,
                },
              };

              // Add category objects for buildProducts compatibility
              const categoryObjects = [];

              // From direct category_ids
              if (Array.isArray(product.category_ids)) {
                product.category_ids.forEach((id) => {
                  const categoryName = categoryMap[String(id)];
                  if (categoryName) {
                    categoryObjects.push({ id: String(id), name: categoryName });
                  }
                });
              }

              // From custom_attributes
              if (Array.isArray(product.custom_attributes)) {
                product.custom_attributes.forEach((attr) => {
                  if (attr.attribute_code === 'category_ids' && Array.isArray(attr.value)) {
                    attr.value.forEach((id) => {
                      const categoryName = categoryMap[String(id)];
                      if (categoryName) {
                        categoryObjects.push({ id: String(id), name: categoryName });
                      }
                    });
                  }
                });
              }

              // Add categories in the format expected by buildProducts
              if (categoryObjects.length > 0) {
                enrichedProduct.categories = categoryObjects;
              }

              // Add images in the format expected by buildProducts
              if (
                Array.isArray(product.media_gallery_entries) &&
                product.media_gallery_entries.length > 0
              ) {
                enrichedProduct.images = product.media_gallery_entries.map(transformImageEntry);
              }

              return enrichedProduct;
            });

            const executionTime = Date.now() - startTime;

            return {
              products: enrichedProducts,
              total_count: enrichedProducts.length,
              message:
                'Successfully fetched and enriched ' +
                enrichedProducts.length +
                ' products with category, inventory, and image data via API Mesh',
              status: 'success',
              performance: {
                processedProducts: enrichedProducts.length,
                apiCalls: 1, // Single mesh query consolidates all API calls
                method: 'API Mesh',
                executionTime: executionTime,
              },
            };
          } catch (error) {
            return {
              products: [],
              total_count: 0,
              message: 'Error: ' + error.message,
              status: 'error',
              performance: {
                processedProducts: 0,
                apiCalls: 1,
                method: 'API Mesh',
                executionTime: Date.now() - startTime,
              },
            };
          }
        },
      },
    },
  },
};

/**
 * Transforms a media gallery entry into a simplified image object.
 * Based on src/commerce/transform/product.js transformImageEntry function
 * @private
 * @param {Object} img - Media gallery entry from Adobe Commerce
 * @param {string} img.file - Image file path
 * @param {number} img.position - Image position/order
 * @param {Array<string>} [img.types] - Image type/role identifiers
 * @returns {Object} Simplified image object
 */
function transformImageEntry(img) {
  // Determine the appropriate URL
  let url;
  if (img.url) {
    // Use the provided URL if available
    url = img.url;
  } else if (img.file && img.file.startsWith('http')) {
    // If file is already a full URL, use it directly
    url = img.file;
  } else {
    // Construct catalog URL for relative paths
    url = 'catalog/product' + img.file;
  }

  const imageObj = {
    filename: img.file,
    url: url,
    position: img.position,
  };
  if (img.types && img.types.length > 0) {
    imageObj.roles = img.types;
  }
  return imageObj;
}

/**
 * Fetch all products using direct REST API calls with existing utilities
 */
async function fetchAllProductsFromSource(context, pageSize, maxPages) {
  const allProducts = [];
  let currentPage = 1;
  let totalPages = 1;

  // Get admin token from context headers
  const adminToken = context.headers['x-commerce-admin-token'];
  if (!adminToken) {
    throw new Error('Admin token required in x-commerce-admin-token header');
  }

  // Use existing Commerce configuration
  const commerceBaseUrl = 'https://citisignal-com774.adobedemo.com';

  do {
    // Build URL using existing Commerce endpoint patterns
    const queryParams = new URLSearchParams({
      'searchCriteria[pageSize]': pageSize,
      'searchCriteria[currentPage]': currentPage,
      fields:
        'items[id,sku,name,price,status,type_id,attribute_set_id,created_at,updated_at,weight,categories,media_gallery_entries,custom_attributes],total_count',
    });

    const url = commerceBaseUrl + '/rest/V1/products?' + queryParams.toString();

    const response = await fetch(url, {
      method: 'GET',
      headers: {
        Authorization: 'Bearer ' + adminToken,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      throw new Error(
        'Products API request failed: ' + response.status + ' ' + response.statusText
      );
    }

    const result = await response.json();

    if (result && result.items) {
      allProducts.push(...result.items);
      totalPages = Math.ceil(result.total_count / pageSize);
    } else {
      break;
    }

    currentPage++;
  } while (currentPage <= totalPages && currentPage <= maxPages);

  return allProducts;
}

/**
 * Fetch category data using direct REST API calls with existing patterns
 */
async function fetchCategoriesFromSource(context, categoryIds) {
  const categoryMap = {};

  // Get admin token from context headers
  const adminToken = context.headers['x-commerce-admin-token'];
  if (!adminToken) {
    throw new Error('Admin token required in x-commerce-admin-token header');
  }

  // Use existing Commerce configuration
  const commerceBaseUrl = 'https://citisignal-com774.adobedemo.com';

  // Batch process categories using optimized batch size (like REST API)
  const meshConfig = __MESH_CONFIG__;
  const batchSize = meshConfig.batching.categories;
  const maxConcurrent = meshConfig.batching.maxConcurrent || 15; // From REST API optimization
  const requestDelay = meshConfig.batching.requestDelay || 75; // From REST API optimization

  for (let i = 0; i < categoryIds.length; i += batchSize) {
    const batch = categoryIds.slice(i, i + batchSize);

    // Process with controlled concurrency (like REST API processConcurrently)
    const categoryPromises = batch.slice(0, maxConcurrent).map(async (categoryId) => {
      try {
        // Use existing category endpoint pattern: /categories/:id
        const url = commerceBaseUrl + '/rest/V1/categories/' + categoryId;

        const response = await fetch(url, {
          method: 'GET',
          headers: {
            Authorization: 'Bearer ' + adminToken,
            'Content-Type': 'application/json',
          },
        });

        if (response.ok) {
          const category = await response.json();
          if (category && category.name) {
            categoryMap[categoryId] = category.name;
          }
        }
      } catch (error) {
        // Skip failed category lookups
        console.warn('Failed to fetch category ' + categoryId + ': ' + error.message);
      }
    });

    await Promise.all(categoryPromises);

    // Add delay between batches (like REST API)
    if (i + batchSize < categoryIds.length) {
      await new Promise((resolve) => setTimeout(resolve, requestDelay));
    }
  }

  return categoryMap;
}

/**
 * Fetch inventory data using direct REST API calls with existing patterns
 */
async function fetchInventoryFromSource(context, skus) {
  const inventoryMap = {};

  // Get admin token from context headers
  const adminToken = context.headers['x-commerce-admin-token'];
  if (!adminToken) {
    throw new Error('Admin token required in x-commerce-admin-token header');
  }

  // Use existing Commerce configuration
  const commerceBaseUrl = 'https://citisignal-com774.adobedemo.com';

  // Batch process inventory using optimized batch size (like REST API)
  const meshConfig = __MESH_CONFIG__;
  const batchSize = meshConfig.batching.inventory;
  const maxConcurrent = meshConfig.batching.maxConcurrent || 15; // From REST API optimization
  const requestDelay = meshConfig.batching.requestDelay || 75; // From REST API optimization

  for (let i = 0; i < skus.length; i += batchSize) {
    const batch = skus.slice(i, i + batchSize);

    // Process with controlled concurrency (like REST API processConcurrently)
    const inventoryPromises = batch.slice(0, maxConcurrent).map(async (sku) => {
      try {
        // Use existing stock item endpoint pattern with search criteria
        const queryParams = new URLSearchParams({
          'searchCriteria[filter_groups][0][filters][0][field]': 'sku',
          'searchCriteria[filter_groups][0][filters][0][value]': sku,
          'searchCriteria[filter_groups][0][filters][0][condition_type]': 'eq',
        });

        const url = commerceBaseUrl + '/rest/V1/stockItems?' + queryParams.toString();

        const response = await fetch(url, {
          method: 'GET',
          headers: {
            Authorization: 'Bearer ' + adminToken,
            'Content-Type': 'application/json',
          },
        });

        if (response.ok) {
          const result = await response.json();
          if (result && result.items && result.items.length > 0) {
            const stockItem = result.items[0];
            inventoryMap[sku] = {
              qty: stockItem.qty || 0,
              is_in_stock: stockItem.is_in_stock || false,
            };
          } else {
            // Default inventory for items not found
            inventoryMap[sku] = { qty: 0, is_in_stock: false };
          }
        } else {
          // Default inventory for failed lookups
          inventoryMap[sku] = { qty: 0, is_in_stock: false };
        }
      } catch (error) {
        // Default inventory for failed lookups
        inventoryMap[sku] = { qty: 0, is_in_stock: false };
      }
    });

    await Promise.all(inventoryPromises);

    // Add delay between batches (like REST API)
    if (i + batchSize < skus.length) {
      await new Promise((resolve) => setTimeout(resolve, requestDelay));
    }
  }

  return inventoryMap;
}
