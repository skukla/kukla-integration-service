# API Mesh Integration with True Mesh Pattern

## Overview

This document describes the implementation of Adobe App Builder API Mesh integration using the **True Mesh Pattern** to consolidate Commerce API calls using embedded custom resolvers that fetch data directly from multiple Commerce APIs within a single GraphQL query.

## Architecture

The True Mesh Pattern consolidates data within the mesh itself:

```text
User Request ‚Üí API Mesh ‚Üí Embedded Resolver ‚Üí Commerce APIs (parallel) ‚Üí Consolidated Data
```text

### Performance Benefits

- **200+ API calls** consolidated into **1 GraphQL query**
- **Parallel data fetching** within mesh resolver
- **Template-generated consistency** across environments
- **Raw data consolidation** with shared transformation logic

## True Mesh Solution (Current Implementation)

The True Mesh pattern provides optimal performance and architectural benefits:

### Architecture Flow

```text
User Request ‚Üí API Mesh ‚Üí Embedded Resolver ‚Üí Commerce APIs ‚Üí Consolidated Data
```text

## Problem Statement

The original `get-products` action makes multiple sequential API calls:

1. **Products API**: `/rest/V1/products` (with pagination)
2. **Inventory API**: `/rest/V1/stockItems/{sku}` (per product SKU)  
3. **Categories API**: `/rest/V1/categories/{categoryId}` (per category)

For 119 products with categories and inventory, this results in **200+ API calls**, leading to:

- High latency due to sequential requests
- Rate limiting concerns  
- Complex error handling
- Poor performance at scale

## True Mesh Pattern (Current Implementation)

The HTTP Bridge pattern solves both performance and architectural challenges:

### Architecture Overview

```text
User Request ‚Üí API Mesh ‚Üí HTTP Bridge Resolver ‚Üí REST Action ‚Üí Commerce API
                ‚Üì                ‚Üì                    ‚Üì
           Single GraphQL    ~60 lines of       Existing business
              Query          HTTP client          logic reused
```text

### Key Benefits

- **üöÄ Performance**: 200+ Commerce API calls ‚Üí 1 GraphQL query
- **üîÑ Zero Duplication**: Single source of truth in REST action
- **üìâ 78% Code Reduction**: 60 lines vs 273 lines embedded logic
- **‚úÖ Perfect Parity**: Identical CSV output, byte-for-byte
- **üõ†Ô∏è Easy Maintenance**: Changes automatically propagate
- **üêõ Standard Debugging**: HTTP patterns everyone understands
- **‚ö° Minimal Overhead**: <1% performance impact

## Implementation

### 1. Mesh Configuration (`mesh.json`)

```json
{
  "meshConfig": {
    "sources": [
      {
        "name": "commercerest",
        "handler": {
          "openapi": {
            "source": "https://citisignal-com774.adobedemo.com/rest/all/schema?services=all"
          }
        }
      },
      {
        "name": "catalogservice", 
        "handler": {
          "graphql": {
            "endpoint": "https://citisignal-com774.adobedemo.com/graphql",
            "operationHeaders": {
              "X-Api-Key": "{context.headers.x-catalog-api-key}",
              "Magento-Environment-Id": "{context.headers.x-catalog-environment-id}",
              "Magento-Store-Code": "{context.headers.x-catalog-store-code}",
              "Content-Type": "application/json"
            }
          }
        }
      }
    ],
    "additionalResolvers": ["./mesh-resolvers.js"],
    "additionalTypeDefs": [
      "type MeshProductsFull { products: [JSON] total_count: Int message: String status: String }",
      "extend type Query { mesh_products_full(pageSize: Int): MeshProductsFull }"
    ]
  }
}
```text

### 2. HTTP Bridge Resolver (`mesh-resolvers.js`)

**Simplified 60-line resolver that eliminates code duplication:**

```javascript
/**
 * Mesh Resolvers - HTTP Bridge Pattern
 * 
 * Benefits:
 * - Single source of truth for Commerce logic
 * - ~60 lines vs 273 lines of embedded logic
 * - Easier to maintain and debug
 * - Automatic synchronization with REST API improvements
 */

// REST action URL (auto-detected environment)
const REST_ACTION_URL = 'https://285361-188maroonwallaby-stage.adobeio-static.net/api/v1/web/kukla-integration-service/get-products';

module.exports = {
  resolvers: {
    Query: {
      mesh_products_full: {
        resolve: async (parent, args, context) => {
          try {
            // Get credentials from headers
            const username = context.headers['x-commerce-username'];
            const password = context.headers['x-commerce-password'];
            
            if (!username || !password) {
              throw new Error('Commerce credentials required via headers: x-commerce-username, x-commerce-password');
            }

            // Call existing REST action via HTTP Bridge
            const urlWithFormat = REST_ACTION_URL + '?format=json';
            const restResponse = await fetch(urlWithFormat, {
              method: 'GET',
              headers: {
                'Content-Type': 'application/json',
                'x-commerce-username': username,
                'x-commerce-password': password,
              },
            });

            if (!restResponse.ok) {
              const errorText = await restResponse.text();
              throw new Error('REST action failed: ' + restResponse.status + ' - ' + errorText);
            }

            const data = await restResponse.json();
            
            // Check if the REST action returned an error
            if (data.error) {
              throw new Error('REST action error: ' + (data.error.message || data.error));
            }

            // Transform REST response to GraphQL format
            return {
              products: data.products || [],
              total_count: data.total_count || (data.products ? data.products.length : 0),
              message: data.message || 'Successfully fetched products via HTTP bridge',
              status: 'success',
            };
          } catch (error) {
            return {
              products: [],
              total_count: 0,
              message: 'Error: ' + error.message,
              status: 'error',
            };
          }
        },
      },
    },
  },
};
```text

### 3. Enhanced REST Action

**Added JSON format support for bridge compatibility:**

```javascript
// In actions/get-products/index.js
async function main(params) {
  // ... existing logic ...
  
  // Check format parameter to determine response type
  const format = actionParams.format || 'csv';

  if (format === 'json') {
    // Return JSON format for API Mesh integration
    return response.success({
      products: builtProducts,
      total_count: builtProducts.length,
      message: 'Successfully fetched ' + builtProducts.length + ' products with category and inventory data',
      status: 'success',
      steps,
      performance: {
        processedProducts: builtProducts.length,
        apiCalls: trace.metrics?.apiCalls || 200,
        method: 'REST API',
      },
    });
  }

  // Default CSV format continues unchanged
  // ... existing CSV logic ...
}
```text

### 4. Simplified Mesh Action

**Optimized for HTTP Bridge pattern:**

```javascript
// actions/get-products-mesh/index.js
async function main(params) {
  // ... validation and setup ...

  // Step 2: Fetch products via HTTP Bridge (single GraphQL call)
  const products = await fetchProductsFromMesh(actionParams, config);
  
  // Step 3: Products already built by REST API, pass through
  const builtProducts = products; // Skip transformation - already done
  
  // Step 4: Create CSV (reused)
  const csvData = await createCsv(builtProducts);
  
  // Step 5: Store CSV (reused)  
  const storageResult = await storeCsv(csvData, actionParams, config);

  return response.success({
    message: 'Product export completed successfully',
    steps,
    downloadUrl: storageResult.downloadUrl,
    storage: { provider: storageResult.storageType, /* ... */ },
    performance: {
      processedProducts: builtProducts.length,
      apiCalls: 1, // API Mesh consolidates many calls into 1
      method: 'REST API',
    },
  });
}
```text

## Performance Comparison

| Method | API Calls | Code Lines | Maintenance | Output |
|--------|-----------|------------|-------------|---------|
| **REST API** | 200+ calls | 157 lines | Single source | 119 products, 15.48 KB |
| **HTTP Bridge** | 1 GraphQL call | 60 lines | Single source | 119 products, 15.48 KB |
| **Embedded Logic** | 1 GraphQL call | 273 lines | Double burden | Same but harder to maintain |

## Configuration

### Environment Configuration

Added to `config/environments/staging.js` and `production.js`:

```javascript
mesh: {
  endpoint: 'https://edge-sandbox-graph.adobe.io/api/e4865722-2b0a-4f3f-bc87-f3302b64487b/graphql',
  timeout: 30000,
}
```text

### Action Configuration (`app.config.yaml`)

```yaml
get-products-mesh:
  function: actions/get-products-mesh/index.js
  web: 'yes'
  runtime: nodejs:18
  inputs:
    NODE_ENV: $NODE_ENV
    COMMERCE_ADMIN_USERNAME: $COMMERCE_ADMIN_USERNAME
    COMMERCE_ADMIN_PASSWORD: $COMMERCE_ADMIN_PASSWORD
    MESH_API_KEY: $MESH_API_KEY
```text

### Environment Variables (`.env`)

```bash
MESH_API_KEY=your_mesh_api_key_here
COMMERCE_ADMIN_USERNAME=admin
COMMERCE_ADMIN_PASSWORD=your_password
```text

## GraphQL Query Structure

### Enhanced Products Query

```graphql
query GetProductsFull($pageSize: Int) {
  mesh_products_full(pageSize: $pageSize) {
    products
    total_count  
    message
    status
  }
}
```text

**Response Structure:**

```json
{
  "data": {
    "mesh_products_full": {
      "products": [
        {
          "sku": "youtube-tv-subscription",
          "name": "YouTube TV", 
          "price": 59.99,
          "qty": 100,
          "categories": [],
          "images": [
            {
              "filename": "https://delivery-p57319-e1619941.adobeaemcloud.com/...",
              "url": "https://delivery-p57319-e1619941.adobeaemcloud.com/...",
              "position": 1,
              "roles": ["image", "small_image", "thumbnail", "swatch_image"]
            }
          ]
        }
      ],
      "total_count": 119,
      "message": "Successfully fetched 119 products with category and inventory data",
      "status": "success"
    }
  }
}
```text

## Testing and Verification

### Identical Output Verification

Both methods produce **100% identical CSV files**:

```bash
# Test both methods
node scripts/test-action.js get-products        # REST API: 119 products, 15.48 KB
node scripts/test-action.js get-products-mesh   # HTTP Bridge: 119 products, 15.48 KB

# Verify identical output
curl -s "REST_DOWNLOAD_URL" > rest_products.csv
curl -s "MESH_DOWNLOAD_URL" > mesh_products.csv
diff rest_products.csv mesh_products.csv        # No differences
```text

### Performance Testing

```bash
# Performance comparison
npm run test:performance get-products           # ~6-8 seconds (200+ API calls)
npm run test:performance get-products-mesh      # ~6-8 seconds (1 GraphQL + REST call)
# Network overhead: <1% (50ms bridge call vs 6+ seconds total)
```text

## API Mesh Constraints & Solutions

### Critical Limitations

1. **Cannot import Node.js modules**: `require('./src/utils')` fails in resolvers
2. **Template literals limited**: Use string concatenation instead
3. **No access to project utilities**: Cannot reuse existing Commerce functions
4. **Global scope only**: Functions must be defined in resolver file

### HTTP Bridge Solutions

‚úÖ **Eliminates all constraints by delegating to existing REST action**
‚úÖ **Reuses all existing utilities automatically**  
‚úÖ **No need for embedded configuration or logic**
‚úÖ **Standard HTTP debugging and error handling**

## Alternative Patterns (Not Recommended)

### Embedded Logic Pattern

‚ùå **Problems:**

- 273 lines of duplicated Commerce logic
- Double maintenance burden  
- Cannot import project utilities
- Complex debugging

### Code Generation Pattern  

‚ùå **Problems:**

- Requires building AST parser (~650 lines)
- Complex meta-programming maintenance
- Over-engineering for simple HTTP bridge solution

## Deployment

### API Mesh Deployment

```bash
# Update mesh with new resolver
aio api-mesh update mesh.json

# Check status
aio api-mesh status
```text

### App Builder Deployment

```bash
# Deploy updated actions
npm run deploy

# Test both methods
node scripts/test-action.js get-products
node scripts/test-action.js get-products-mesh
```text

## Troubleshooting

### Common Issues

1. **400 Error "Request defines parameters that are not allowed"**
   - **Solution**: Use GET with query parameters for staging environment
   - **Code**: `fetch(URL + '?format=json', { method: 'GET' })`

2. **Missing image URLs in CSV**
   - **Solution**: Skip `buildProducts` step in mesh action  
   - **Reason**: HTTP bridge returns already-transformed data

3. **Mesh resolver timeout**
   - **Solution**: Check REST action is deployed and accessible
   - **Debug**: Test REST action directly with `?format=json`

### Debug Commands

```bash
# Test mesh resolver directly
curl -X POST "MESH_ENDPOINT" \
  -H "Authorization: Bearer $MESH_API_KEY" \
  -H "x-commerce-username: admin" \
  -H "x-commerce-password: $PASSWORD" \
  -d '{"query": "{ mesh_products_full { total_count status } }"}'

# Test REST action JSON format  
curl "REST_ACTION_URL?format=json" | jq '.products | length'

# Check mesh logs
aio api-mesh log-list
aio api-mesh log-get RAYID
```text

## Best Practices

1. **Always use HTTP Bridge pattern** for new API Mesh integrations
2. **Add JSON format support** to existing REST actions for bridge compatibility
3. **Skip transformation steps** when using already-transformed data
4. **Verify identical output** when implementing mesh alternatives
5. **Use existing test scripts** for consistent validation
6. **Document architectural decisions** for future reference

## Future Enhancements

- **Production Environment**: Deploy to production workspace
- **Error Monitoring**: Enhanced error tracking for bridge calls  
- **Caching**: Add response caching for improved performance
- **Rate Limiting**: Implement mesh-specific rate limiting
- **Monitoring**: GraphQL query performance metrics

## Smart Mesh Resolver Generation

The project includes an intelligent mesh resolver generation system that only regenerates resolvers when necessary, improving build performance and preventing unnecessary mesh updates.

### Change Detection

The system uses SHA-256 hashes to detect changes in:

- **Template file** (`mesh-resolvers.template.js`)
- **Mesh configuration** (pagination, batching, timeout settings)

Generation metadata is embedded in the generated resolver file to track:

```javascript
/* GENERATION_METADATA: {"templateHash":"abc123...","configHash":"def456...","generatedAt":"2025-06-29T19:42:58.514Z","version":"1.0.0"} */
```text

### Available Commands

```bash
# Smart generation (only if changes detected)
npm run build:mesh-resolver

# Force regeneration (bypass change detection)
npm run build:mesh-resolver:force

# Verbose mode (shows hash details)
npm run build:mesh-resolver:check
```text

### Example Output

**No changes detected:**

```text
‚úÖ Mesh resolver is up to date
   Reason: No changes detected
```text

**Changes detected:**

```text
üîÑ Generating mesh resolver...
   Reason: Template file has changed
‚úÖ Successfully generated mesh-resolvers.js from template
   - Generated at: 2025-06-29T19:42:58.514Z
```text

**Verbose mode:**

```text
üîç Change detection details:
   Template hash: dd2969d8... (existing: dd2969d8...)
   Config hash: b6908095... (existing: b6908095...)
   Last generated: 2025-06-29T19:42:58.514Z
‚úÖ Mesh resolver is up to date
   Use --force to regenerate anyway
```text

### Build Integration

The smart generation is integrated into the main build process (`scripts/build.js`). During deployment:

1. **Environment detection** - Determines staging vs production
2. **Schema validation** - Validates configuration schemas  
3. **Frontend generation** - Generates frontend assets
4. **Smart mesh generation** - Only regenerates if needed

This ensures efficient builds that don't unnecessarily update the mesh when no changes have occurred.

## Enhanced Deployment with Automatic Mesh Updates

The project includes an enhanced deployment system that automatically handles API Mesh updates when mesh resolvers change.

### How It Works

When you run `npm run deploy`, the system:

1. **Detects Changes**: Uses SHA-256 hash comparison to determine if mesh resolvers need regeneration
2. **Smart Generation**: Only regenerates resolvers if template or configuration changes detected
3. **Automatic Mesh Update**: If resolvers were regenerated, automatically updates API Mesh
4. **Retry Logic**: Retries mesh updates up to 3 times with 90-second provisioning waits
5. **Status Verification**: Confirms mesh update success before completing deployment

### Deployment Flow

```text
npm run deploy
‚îú‚îÄ‚îÄ Environment Detection
‚îú‚îÄ‚îÄ Clean Build Artifacts  
‚îú‚îÄ‚îÄ Build Process (includes smart mesh resolver generation)
‚îú‚îÄ‚îÄ Check Mesh Resolver Status
‚îú‚îÄ‚îÄ Deploy App Builder Actions
‚îî‚îÄ‚îÄ Conditional Mesh Update (if resolvers changed)
    ‚îú‚îÄ‚îÄ Update API Mesh (with retry logic)
    ‚îú‚îÄ‚îÄ Wait 90 seconds for provisioning
    ‚îú‚îÄ‚îÄ Check mesh status
    ‚îî‚îÄ‚îÄ Retry if needed (up to 3 attempts)
```text

### Example Output

**No mesh changes needed:**
```text
üöÄ Starting enhanced deployment to staging...
‚úÖ Environment detected: staging
‚úÖ Build artifacts cleaned
‚úÖ Build process completed
‚úÖ Mesh resolver: No changes detected
‚úÖ App Builder actions deployed
‚úÖ Mesh resolver unchanged. No mesh update needed.
ÔøΩÔøΩ Deployment to staging completed successfully!
```text

**Mesh update required:**
```text
üöÄ Starting enhanced deployment to staging...
‚úÖ Environment detected: staging
‚úÖ Build artifacts cleaned
‚úÖ Build process completed
‚úÖ Mesh resolver: Changes detected in template or configuration
‚úÖ App Builder actions deployed

üîÑ Mesh resolver was regenerated. Updating API Mesh automatically...

üîÑ API Mesh update attempt 1/3 for staging...
‚úÖ Sent update command to API Mesh in staging
Update command sent. Mesh is provisioning...
‚úÖ Wait complete.
‚úÖ Checked mesh status

------------------- MESH STATUS -------------------
Status: success
Endpoint: https://graph.adobe.io/api/mesh-id/graphql
-------------------------------------------------

‚úÖ API Mesh update successful!
üéâ Deployment to staging completed successfully!
```text

### Manual Override

If automatic mesh update fails, you can run it manually:

```bash
# For staging
npm run deploy:mesh

# For production  
npm run deploy:mesh:prod
```text

### Benefits

- **Zero Manual Steps**: Mesh updates happen automatically when needed
- **Efficient**: Only updates mesh when resolvers actually change
- **Reliable**: Retry logic handles temporary mesh provisioning issues
- **Safe**: Verifies mesh status before considering deployment complete
- **Transparent**: Clear feedback about what's happening during deployment
